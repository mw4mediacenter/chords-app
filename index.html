<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"/>
  <meta name="apple-mobile-web-app-capable" content="yes"/>
  <meta name="apple-mobile-web-app-status-bar-style" content="default"/>
  <title>Chords (Piano)</title>

  <link rel="icon" href='data:image/svg+xml;utf8,
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 128 128">
    <defs><linearGradient id="g" x1="0" y1="0" x2="0" y2="1">
      <stop offset="0" stop-color="%23007aff"/><stop offset="1" stop-color="%23004fb3"/>
    </linearGradient></defs>
    <rect rx="28" ry="28" width="128" height="128" fill="url(%23g)"/>
    <text x="64" y="82" font-size="64" text-anchor="middle" fill="white" font-family="system-ui">ðŸŽ¹</text>
  </svg>'/>

  <style>
    :root{
      --bg:#f2f3f5; --card:#ffffff; --card2:#ffffff; --txt:#0f172a; --mut:#6b7280; --line:#e5e7eb;
      --bubble:#f7c948; --bubbleText:#1a1a1a;
      --whiteKey:#ffffff; --whiteKeyBorder:#cfd5df;
      --shadow:0 10px 24px rgba(15, 23, 42, .08);
      --iosBlue:#007aff;
      --segBg:#e5e7eb; --segChip:#ffffff;
    }
    [data-theme="dark"]{
      --bg:#0b0c10; --card:#12141b; --card2:#0f1117; --txt:#eaeefb; --mut:#aab3cc; --line:#2a2f3b;
      --whiteKey:#f3f4f6; --whiteKeyBorder:#374151;
      --shadow:0 18px 40px rgba(0,0,0,.35);
      --segBg:#2a2f3b; --segChip:#12141b;
    }

    *{box-sizing:border-box}
    body{margin:0; font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial; background:var(--bg); color:var(--txt);}
    .app{max-width:1200px; margin:0 auto; padding:14px; display:grid; grid-template-columns:360px 1fr; gap:12px;}
    @media(max-width:980px){ .app{ grid-template-columns:1fr; } }

    .panel{background:var(--card); border:1px solid var(--line); border-radius:16px; box-shadow:var(--shadow); overflow:hidden;}

    .topbar{display:flex; align-items:center; justify-content:space-between; padding:10px 12px; border-bottom:1px solid var(--line); background:var(--card2);}
    .topbar .leftGroup{display:flex; gap:10px; align-items:center;}
    .iconBtn{width:34px; height:34px; border-radius:10px; border:1px solid var(--line); background:transparent; display:grid; place-items:center; cursor:pointer; user-select:none; font-weight:900;}
    .tabs{display:inline-flex; border:1px solid var(--line); background:var(--card2); border-radius:12px; overflow:hidden;}
    .tabs button{border:0; background:transparent; color:var(--mut); padding:7px 12px; font-weight:900; font-size:14px; cursor:pointer;}
    .tabs button.active{background:rgba(0,0,0,.04); color:var(--txt);}
    [data-theme="dark"] .tabs button.active{background:rgba(255,255,255,.06);}
    .starBtn{font-size:22px; font-weight:900; border:0; background:transparent; cursor:pointer; color:var(--iosBlue); padding:6px 8px; user-select:none;}

    .left{display:flex; flex-direction:column; height:min(860px, calc(100vh - 28px));}
    .hdr{padding:12px 12px 6px; font-size:44px; font-weight:900; letter-spacing:-.02em;}

    /* Search with clear (X) */
    .searchWrap{padding:8px 12px 8px; position:relative;}
    .search{width:100%; padding:10px 40px 10px 12px; border-radius:12px; border:1px solid var(--line); background:transparent; color:var(--txt); font-size:15px; outline:none;}
    .clearSearchBtn{
      position:absolute; right:22px; top:50%; transform:translateY(-50%);
      width:26px; height:26px; border-radius:999px;
      border:1px solid var(--line); background:var(--card2);
      display:none; align-items:center; justify-content:center;
      cursor:pointer; user-select:none; font-weight:900; color:var(--mut);
    }
    .clearSearchBtn.show{display:flex;}
    .clearSearchBtn:active{transform:translateY(-50%) scale(.96);}

    .underSearch{padding:0 12px 10px; display:flex; gap:10px; align-items:center; flex-wrap:wrap;}
    .rootScroll{display:flex; gap:10px; overflow:auto; padding:6px 6px; border:1px solid var(--line); border-radius:12px; background:var(--card2); max-width:220px;}
    .rootScroll button{border:0; background:transparent; font-weight:900; color:rgba(15,23,42,.35); cursor:pointer; padding:6px 8px; border-radius:10px; white-space:nowrap;}
    [data-theme="dark"] .rootScroll button{color:rgba(234,238,251,.35);}
    .rootScroll button.active{color:var(--txt); background:rgba(0,0,0,.04);}
    [data-theme="dark"] .rootScroll button.active{background:rgba(255,255,255,.06);}

    .rangeBox{display:flex; gap:8px; align-items:center; font-weight:900; color:var(--mut); font-size:12px;}
    .rangeBox select{border:1px solid var(--line); border-radius:10px; background:transparent; color:var(--txt); padding:7px 10px; font-weight:900;}

    .rootRow{display:flex; gap:14px; padding:6px 12px 0; align-items:center; font-size:34px; font-weight:900;}
    .rootRow small{font-size:16px; color:var(--mut); font-weight:800;}

    .invMiniSeg{padding:8px 12px 10px; display:flex; align-items:center; justify-content:space-between; gap:10px;}
    .miniSeg{display:inline-flex; gap:0; border:1px solid var(--line); border-radius:12px; overflow:hidden; background:var(--card2);}
    .miniSeg button{border:0; border-right:1px solid var(--line); background:transparent; padding:6px 10px; font-weight:900; color:var(--mut); cursor:pointer; font-size:12px;}
    .miniSeg button:last-child{border-right:0}
    .miniSeg button.active{background:rgba(0,0,0,.04); color:var(--txt);}
    [data-theme="dark"] .miniSeg button.active{background:rgba(255,255,255,.06);}
    .favToggle{color:var(--iosBlue); font-weight:900; cursor:pointer; user-select:none; font-size:13px; white-space:nowrap;}

    .list{overflow:auto; padding:6px 0; flex:1;}
    .item{display:flex; align-items:center; gap:10px; padding:10px 12px; cursor:pointer; border-left:4px solid transparent;}
    .item:hover{background:rgba(0,0,0,.03);}
    [data-theme="dark"] .item:hover{background:rgba(255,255,255,.04);}
    .item.active{background:rgba(0,122,255,.10); border-left-color:var(--iosBlue);}
    .item .name{min-width:70px; font-weight:900; font-size:18px;}
    .item .sub{color:var(--mut); font-size:12px; font-weight:800; margin-top:2px;}
    .miniKbd{flex:1; min-width:160px;}

    .filterBtn{padding:10px 12px; border-top:1px solid var(--line); color:var(--iosBlue); font-weight:900; display:flex; gap:8px; align-items:center;}

    .right{display:flex; flex-direction:column; min-height:min(860px, calc(100vh - 28px));}
    .bigChordTitle{text-align:center; font-size:28px; font-weight:900; padding:14px 0 8px; color:rgba(15,23,42,.55);}
    [data-theme="dark"] .bigChordTitle{color:rgba(234,238,251,.55);}

    .pickerBlock{padding:0 12px 10px;}
    .rowPicker{display:flex; align-items:center; justify-content:space-between; gap:10px; border-top:1px solid var(--line); padding:10px 0;}
    .leftArrow,.rightArrow{color:var(--iosBlue); font-weight:900; font-size:22px; padding:4px 8px; cursor:pointer; user-select:none;}
    .noteRail{display:flex; gap:18px; align-items:center; justify-content:center; flex:1; font-size:20px; font-weight:900;}
    .noteRail span{color:rgba(15,23,42,.35);}
    [data-theme="dark"] .noteRail span{color:rgba(234,238,251,.35);}
    .noteRail span.active{color:var(--txt);}
    .qualRail{display:flex; align-items:center; justify-content:center; flex:1; font-size:18px; font-weight:900;}
    .qualRail .mut{color:rgba(15,23,42,.35); font-weight:800;}
    [data-theme="dark"] .qualRail .mut{color:rgba(234,238,251,.35);}

    .sectionTitle{padding:12px 12px 8px; font-size:18px; font-weight:900; color:rgba(15,23,42,.45);}
    [data-theme="dark"] .sectionTitle{color:rgba(234,238,251,.45);}

    .invBar{padding:0 12px 10px; display:flex; justify-content:space-between; align-items:center; gap:10px; flex-wrap:wrap;}
    .staffBox{margin:0 12px 12px; border-top:1px solid var(--line); padding-top:10px;}
    .staffSvg{width:100%; height:120px; display:block;}

    .infoTable{margin:0 12px 12px; border-top:1px solid var(--line);}
    .infoRow{display:flex; justify-content:space-between; gap:10px; padding:12px 0; border-bottom:1px solid var(--line);}
    .infoRow .k{color:rgba(15,23,42,.55); font-weight:900;}
    [data-theme="dark"] .infoRow .k{color:rgba(234,238,251,.55);}
    .infoRow .v{font-weight:900; color:rgba(15,23,42,.45);}
    [data-theme="dark"] .infoRow .v{color:rgba(234,238,251,.55);}

    .toggle{width:52px; height:30px; border-radius:999px; border:1px solid var(--line); position:relative; background:rgba(0,0,0,.05); cursor:pointer; user-select:none;}
    [data-theme="dark"] .toggle{background:rgba(255,255,255,.08);}
    .toggle .knob{position:absolute; top:3px; left:3px; width:24px; height:24px; border-radius:50%; background:var(--card); box-shadow:0 4px 10px rgba(0,0,0,.12); transition:.2s;}
    .toggle.on{background:rgba(0,122,255,.25); border-color:rgba(0,122,255,.45);}
    .toggle.on .knob{left:25px;}

    .kbdArea{margin-top:auto; border-top:1px solid var(--line); background:var(--card2);}
    .kbdMain{padding:0; height:260px; overflow:hidden;}
    .kbdMain svg{width:100%; height:100%; display:block;}

    .kbdBar{border-top:1px solid var(--line); background:rgba(0,0,0,.03); display:flex; align-items:center; justify-content:space-between; padding:12px 14px; gap:12px;}
    [data-theme="dark"] .kbdBar{background:rgba(255,255,255,.04);}

    .playBig{width:56px; height:56px; border-radius:14px; border:0; background:transparent; color:var(--iosBlue); font-size:30px; cursor:pointer; display:grid; place-items:center; user-select:none;}
    .clearBtn{border:1px solid var(--line); background:transparent; color:var(--txt); font-weight:900; padding:10px 14px; border-radius:14px; cursor:pointer; user-select:none;}
    .clearBtn:active{transform:scale(.98);}

    .segIOS{background:var(--segBg); border-radius:14px; padding:4px; display:inline-flex; gap:4px; align-items:center; min-width:330px; justify-content:center;}
    .segIOS button{border:0; background:transparent; padding:10px 14px; border-radius:12px; font-weight:900; cursor:pointer; color:rgba(15,23,42,.65); user-select:none;}
    [data-theme="dark"] .segIOS button{color:rgba(234,238,251,.75);}
    .segIOS button.active{background:var(--segChip); color:var(--txt); box-shadow:0 6px 18px rgba(0,0,0,.08);}

    .dots{color:var(--iosBlue); font-size:22px; font-weight:900; letter-spacing:6px; padding-right:10px; user-select:none;}
    .err{color:#b91c1c; font-weight:900; text-align:center; padding:8px 12px; display:none;}
    [data-theme="dark"] .err{color:#ff8a8a;}

    .viewHide{display:none !important;}
  </style>
</head>

<body data-theme="light">
  <div class="app">

    <!-- LEFT -->
    <div class="panel left">
      <div class="topbar">
        <div class="leftGroup">
          <button class="iconBtn" id="themeBtn" title="Toggle theme">â˜€ï¸Ž</button>
          <div class="tabs" id="topTabs">
            <button class="active" data-tab="root">Root</button>
            <button data-tab="piano">Piano</button>
            <button data-tab="staff">Staff</button>
          </div>
        </div>
        <button class="starBtn" id="favBtn" title="Favorite">â˜†</button>
      </div>

      <div class="hdr">Chords</div>

      <div class="searchWrap">
        <input class="search" id="searchInput" placeholder="Search Chords (legacy / modern / words: â€œB half diminishedâ€)"/>
        <div class="clearSearchBtn" id="clearSearchBtn" title="Clear">Ã—</div>
      </div>

      <!-- Under-search controls (Root + Range) -->
      <div class="underSearch">
        <div class="rootScroll" id="rootScroll"></div>

        <div class="rangeBox">
          <span>Range:</span>
          <select id="rangeStart">
            <option value="2">C2</option>
            <option value="3" selected>C3</option>
            <option value="4">C4</option>
          </select>
          <span>to</span>
          <select id="rangeEnd">
            <option value="4" selected>C4</option>
            <option value="5">C5</option>
            <option value="6">C6</option>
          </select>
        </div>
      </div>

      <div class="rootRow">
        <div id="leftRootBig">C</div>
        <small id="leftRootRail">C#  Db  D  D#  Eb</small>
      </div>

      <div class="invMiniSeg">
        <div class="miniSeg" id="leftInvSeg">
          <button class="active" data-inv="0">Root</button>
          <button data-inv="1">1st</button>
          <button data-inv="2">2nd</button>
          <button data-inv="3">3rd</button>
          <button data-inv="4">4th</button>
          <button data-inv="5">5th</button>
          <button data-inv="6">6th</button>
        </div>
        <div class="favToggle" id="favFilterBtn">Show â˜…</div>
      </div>

      <div class="list" id="chordList"></div>
      <div class="filterBtn">â˜° <span>Filter Chords</span></div>
    </div>

    <!-- RIGHT -->
    <div class="panel right">
      <div class="bigChordTitle" id="rightTitle">Cm</div>

      <div class="pickerBlock" id="pickerBlock">
        <div class="rowPicker">
          <div class="leftArrow" id="rootPrev">â€¹</div>
          <div class="noteRail" id="noteRail"></div>
          <div class="rightArrow" id="rootNext">â€º</div>
        </div>

        <div class="rowPicker">
          <div class="leftArrow" id="qualPrev">â€¹</div>
          <div class="qualRail" id="qualRail"></div>
          <div class="rightArrow" id="qualNext">â€º</div>
        </div>
      </div>

      <div id="rootView">
        <div class="sectionTitle">Inversion</div>
        <div class="invBar">
          <div class="miniSeg" id="rightInvSeg"></div>
          <div style="color:var(--mut);font-weight:900;font-size:12px" id="legacyLine">â€”</div>
        </div>

        <div class="staffBox" id="staffBox">
          <svg class="staffSvg" id="staffSvg" viewBox="0 0 800 140" xmlns="http://www.w3.org/2000/svg"></svg>
        </div>

        <div class="infoTable" id="infoTable">
          <div class="infoRow"><div class="k">Degrees</div><div class="v" id="degText">â€”</div></div>
          <div class="infoRow"><div class="k">Notes</div><div class="v" id="noteText">â€”</div></div>
          <div class="infoRow">
            <div class="k">Loop</div>
            <div class="v"><div class="toggle" id="loopToggle"><div class="knob"></div></div></div>
          </div>
        </div>

        <div class="err" id="err"></div>
      </div>

      <div class="kbdArea" id="pianoView">
        <div class="kbdMain" id="kbdMain"></div>

        <div class="kbdBar">
          <button class="playBig" id="playBtn" title="Play">â–¶</button>

          <button class="clearBtn" id="clearBtn" title="Clear (Piano mode)">Clear</button>

          <div class="segIOS" id="arpSeg">
            <button class="active" data-arp="off">At Once</button>
            <button data-arp="asc">Ascending</button>
            <button data-arp="desc">Descending</button>
          </div>

          <div class="dots">â€¢â€¢â€¢</div>
        </div>
      </div>
    </div>

  </div>

<script>
/* ================= Notes / pitch classes ================= */
const NOTE_SHARP = ["C","C#","D","D#","E","F","F#","G","G#","A","A#","B"];
const NOTE_FLAT  = ["C","Db","D","Eb","E","F","Gb","G","Ab","A","Bb","B"];
const FLAT_TO_SHARP = {"Db":"C#","Eb":"D#","Gb":"F#","Ab":"G#","Bb":"A#"};
const ROOTS_RAIL = ["C","C#","Db","D","D#","Eb","E","F","F#","Gb","G","G#","Ab","A","A#","Bb","B"];

function toPc(note){ return NOTE_SHARP.indexOf(note); }
function pcName(pc, preferFlats=false){
  pc=((pc%12)+12)%12;
  return preferFlats ? NOTE_FLAT[pc] : NOTE_SHARP[pc];
}
function normRoot(s){
  const m=s.match(/^([A-Ga-g])([#b]?)/);
  if(!m) return null;
  let r=m[1].toUpperCase()+(m[2]||"");
  if(FLAT_TO_SHARP[r]) r=FLAT_TO_SHARP[r];
  if(!NOTE_SHARP.includes(r)) return null;
  return r;
}
function uniq(a){ return [...new Set(a)]; }

/* ================= Natural language chord search ================= */
function normalizeWordSearch(raw){
  let s=(raw||"").trim();
  if(!s) return s;

  // common phrases -> symbols / conventional
  const lower=s.toLowerCase().replace(/\s+/g," ").trim();

  // Extract root at start (e.g., "B half diminished")
  const m = s.trim().match(/^([A-Ga-g])([#b]?)(.*)$/);
  if(!m) return s;

  const root = (m[1].toUpperCase() + (m[2]||""));
  let rest = (m[3]||"").trim();

  // If the rest contains any slash legacy things already, keep raw
  // but still allow words to convert
  const restLower = rest.toLowerCase();

  // half diminished => m7b5
  if(restLower.includes("half diminished") || restLower.includes("half-diminished") || restLower.includes("halfdiminished")){
    return root + "m7b5";
  }

  // fully diminished
  if(restLower.includes("diminished") || restLower.includes("dim")){
    // allow "diminished seventh"
    if(restLower.includes("7") || restLower.includes("seventh")) return root + "dim7";
    return root + "dim";
  }

  // major / minor / aug / sus
  if(restLower.includes("major 7") || restLower.includes("major7") || restLower.includes("maj7")) return root + "maj7";
  if(restLower.includes("minor 7") || restLower.includes("minor7") || restLower.includes("min7") || restLower.includes("m7")) return root + "m7";
  if(restLower.includes("minor")) return root + "m";
  if(restLower.includes("augmented") || restLower.includes("aug")) return root + "aug";
  if(restLower.includes("sus2")) return root + "sus2";
  if(restLower.includes("sus4") || restLower.includes("sus")) return root + "sus4";

  // fallback - if user typed root only
  if(!rest) return root;

  // otherwise keep original
  return s;
}

/* ================= Legacy normalization ================= */
function normalizeLegacyNotation(raw){
  let s=(raw||"").trim();
  if(!s) return s;
  s=s.replace(/\s+/g,"");
  if(!s.includes("/")) return s;

  const parts=s.split("/").filter(Boolean);
  if(parts.length===2 && normRoot(parts[1])) return s; // real slash chord

  const base=parts[0];
  let tokens=parts.slice(1);

  let bass=null;
  if(tokens.length && normRoot(tokens[tokens.length-1])) bass=tokens.pop();

  let addStr="";
  for(const t of tokens){
    if(/^(7|6|9|11|13)$/.test(t)){ addStr+=t; continue; }
    const m=t.match(/^(5|9|11|13)([+-])$/);
    if(m){ addStr+=(m[2]==="+"?"#":"b")+m[1]; continue; }
    addStr+=t;
  }
  let out=base+addStr;
  if(bass) out+="/"+bass;
  return out;
}
function modernToLegacy(s){
  const parts=s.split("/");
  const main=parts[0];
  const bass=parts.length>1?"/"+parts.slice(1).join("/"):"";
  const out=main.replace(/([b#])(5|9|11|13)/g,(_,bsh,deg)=>"/"+deg+(bsh==="#"?"+":"-"));
  return out+bass;
}

/* ================= Chord build ================= */
function baseTriad(quality){
  switch(quality){
    case "min": return [0,3,7];
    case "dim": return [0,3,6];
    case "aug": return [0,4,8];
    case "sus2": return [0,2,7];
    case "sus4": return [0,5,7];
    default: return [0,4,7];
  }
}
function addIfMissing(ints,x){ if(!ints.includes(x)) ints.push(x); }
function removeInterval(ints,x){ const i=ints.indexOf(x); if(i>=0) ints.splice(i,1); }

function applyAlterations(ints, alts){
  const degToInt = (deg)=> deg===9?14 : deg===11?17 : deg===13?21 : null;
  for(const a of alts){
    if(a.deg===5){
      removeInterval(ints,7); removeInterval(ints,6); removeInterval(ints,8);
      addIfMissing(ints, 7 + a.delta);
      continue;
    }
    const base = degToInt(a.deg);
    if(base==null) continue;
    removeInterval(ints, base);
    addIfMissing(ints, base + a.delta);
  }
}

function parseChord(inputRaw){
  const legacyInput=(inputRaw||"").trim();
  if(!legacyInput) return {error:"Empty input"};

  // NEW: word search normalization before everything
  const wordNormalized = normalizeWordSearch(legacyInput);

  const normalized = normalizeLegacyNotation(wordNormalized)
    .replace(/Î”/gi,"maj")
    .replace(/7\+/gi,"maj7")
    .replace(/Ã¸/gi,"m7b5")
    .replace(/Â°/g,"dim");

  let s=normalized;

  let bass=null;
  if(s.includes("/")){
    const parts=s.split("/");
    s=parts[0].trim();
    bass=normRoot(parts[1].trim());
    if(!bass) return {error:"Invalid slash bass note"};
  }

  const root=normRoot(s);
  if(!root) return {error:"Invalid root"};
  let tail=s.slice(root.length);

  let quality="maj";
  if(/^m(?!aj)/i.test(tail)){ quality="min"; tail=tail.replace(/^m(?!aj)/i,""); }
  if(/^min/i.test(tail)){ quality="min"; tail=tail.replace(/^min/i,""); }
  if(/^maj/i.test(tail)){ quality="maj"; tail=tail.replace(/^maj/i,""); }
  if(/^dim/i.test(tail)){ quality="dim"; tail=tail.replace(/^dim/i,""); }
  if(/^aug/i.test(tail) || /^\+/i.test(tail)){ quality="aug"; tail=tail.replace(/^aug/i,"").replace(/^\+/i,""); }
  if(/^sus2/i.test(tail)){ quality="sus2"; tail=tail.replace(/^sus2/i,""); }
  if(/^sus4/i.test(tail) || /^sus/i.test(tail)){ quality="sus4"; tail=tail.replace(/^sus4/i,"").replace(/^sus/i,""); }

  let want7=false, maj7=false, dim7=false;
  let want6=false, want9=false, want11=false, want13=false;
  let halfDim=false, mMaj7=false;

  if(/m7b5/i.test(s)) halfDim=true;
  if(/dim7/i.test(s) || /o7/i.test(s)) dim7=true;
  if(/mMaj7/i.test(s) || /mmaj7/i.test(s)) mMaj7=true;

  if(/13/.test(tail)) want13=true;
  else if(/11/.test(tail)) want11=true;
  else if(/9/.test(tail)) want9=true;

  if(/maj7/i.test(tail)) { maj7=true; want7=true; tail=tail.replace(/maj7/ig,""); }
  if(/m7b5/i.test(tail)) { halfDim=true; want7=true; tail=tail.replace(/m7b5/ig,""); }
  if(/dim7/i.test(tail)) { dim7=true; want7=true; tail=tail.replace(/dim7/ig,""); }
  if(/mMaj7|mmaj7/i.test(tail)) { mMaj7=true; want7=true; tail=tail.replace(/mMaj7|mmaj7/ig,""); }
  if(/7/.test(tail)) { want7=true; tail=tail.replace(/7/ig,""); }
  if(/69/.test(tail)) { want6=true; want9=true; tail=tail.replace(/69/ig,""); }
  if(/6/.test(tail)) { want6=true; tail=tail.replace(/6/ig,""); }

  const alts=[];
  const altRe=/([b#])(5|9|11|13)/ig; let m;
  while((m=altRe.exec(normalized))!==null){
    alts.push({deg:parseInt(m[2],10), delta:(m[1]==="b"?-1:+1)});
  }

  const preferFlats = /b/.test(normalized) && !/#/.test(normalized);
  return {root,bass,quality,want7,maj7,dim7,want6,want9,want11,want13,halfDim,mMaj7,alts,preferFlats,legacyInput,normalizedInput:normalized};
}

function normalizeDisplayName(p){
  let name=p.root;

  if(p.halfDim) name+="m7b5";
  else if(p.dim7) name+="dim7";
  else{
    if(p.quality==="min") name+="m";
    else if(p.quality==="dim") name+="dim";
    else if(p.quality==="aug") name+="aug";
    else if(p.quality==="sus2") name+="sus2";
    else if(p.quality==="sus4") name+="sus4";

    if(p.mMaj7) name+="Maj7";
    else if(p.maj7) name+="maj7";
    else if(p.want7) name+="7";

    if(p.want13) name+="13";
    else if(p.want11) name+="11";
    else if(p.want9) name+="9";

    if(p.want6 && !/69/.test(p.normalizedInput)) name+="6";
    if(/69/.test(p.normalizedInput)) name+="69";
  }

  const alts=[]; const altRe=/([b#])(5|9|11|13)/ig; let m;
  while((m=altRe.exec(p.normalizedInput))!==null) alts.push(m[1]+m[2]);
  if(alts.length) name+=alts.join("");

  if(p.bass) name+="/"+p.bass;
  return name;
}

function buildChord(p){
  const rootPc=toPc(p.root);
  let ints=baseTriad(p.quality).slice();

  if(p.halfDim){ ints=baseTriad("dim"); addIfMissing(ints,10); }
  if(p.dim7){ ints=baseTriad("dim"); addIfMissing(ints,9); }

  if(p.want7 || p.maj7 || p.mMaj7){
    if(p.mMaj7){ ints=baseTriad("min"); addIfMissing(ints,11); }
    else if(p.maj7) addIfMissing(ints,11);
    else if(!p.dim7 && !p.halfDim) addIfMissing(ints,10);
  }
  if(p.want6) addIfMissing(ints,9);

  if(p.want9 || p.want11 || p.want13){
    if(!ints.includes(10) && !ints.includes(11) && !ints.includes(9)){
      addIfMissing(ints, (p.maj7 ? 11 : 10));
    }
    addIfMissing(ints,14);
  }
  if(p.want11 || p.want13) addIfMissing(ints,17);
  if(p.want13) addIfMissing(ints,21);

  applyAlterations(ints, p.alts);

  const pcs = uniq(ints.map(i => (rootPc + (i%12) + 12)%12));
  const bassPc = p.bass ? toPc(p.bass) : null;
  return {pcs, bassPc, rootPc, ints, modernName: normalizeDisplayName(p)};
}

/* ================= Inversions ================= */
function inversionsFromPcs(pcs){
  const base = pcs.slice().sort((a,b)=>a-b);
  const out=[];
  for(let k=0;k<base.length;k++){
    out.push(base.slice(k).concat(base.slice(0,k)));
  }
  return out;
}
function invLabel(idx){
  if(idx===0) return "Root";
  if(idx===1) return "1st";
  if(idx===2) return "2nd";
  if(idx===3) return "3rd";
  if(idx===4) return "4th";
  if(idx===5) return "5th";
  if(idx===6) return "6th";
  return idx+"th";
}

/* ================= Degrees ================= */
function degreesFromIntervals(ints){
  const map = {0:"1",1:"b2",2:"2",3:"b3",4:"3",5:"4",6:"b5",7:"5",8:"#5",9:"6",10:"b7",11:"7"};
  const pcs = uniq(ints.map(i => ((i%12)+12)%12)).sort((a,b)=>a-b);
  const extra = [];
  if(ints.some(i=>i>=14)) extra.push("9");
  if(ints.some(i=>i>=17)) extra.push("11");
  if(ints.some(i=>i>=21)) extra.push("13");
  const out = pcs.map(pc => map[pc] || "?");
  extra.forEach(x=>{ if(!out.includes(x)) out.push(x); });
  return out.join(", ");
}

/* ================= Bubble collision avoidance ================= */
function resolveBubbleCollisions(bubbles, radius, pad){
  if(bubbles.length <= 1) return bubbles;
  const minDist = (radius*2) + pad;
  bubbles.sort((a,b)=>a.x-b.x);
  for(let pass=0; pass<6; pass++){
    for(let i=0;i<bubbles.length;i++){
      for(let j=i+1;j<bubbles.length;j++){
        const a=bubbles[i], b=bubbles[j];
        const dx=b.x-a.x, dy=b.y-a.y;
        const dist=Math.sqrt(dx*dx+dy*dy);
        if(dist < minDist){
          const push = (minDist - dist)/2 + 0.5;
          a.x -= push; b.x += push;
        }
      }
    }
  }
  return bubbles;
}

/* ================= Staff preview ================= */
function renderStaff(svgEl, pcs, preferFlats){
  const svgW=800;
  const lineY=[30,42,54,66,78];
  let s="";
  for(const y of lineY){
    s+=`<line x1="40" y1="${y}" x2="${svgW-40}" y2="${y}" stroke="rgba(107,114,128,.55)" stroke-width="2"/>`;
  }
  const sorted=pcs.slice().sort((a,b)=>a-b);
  const x0=120, dx=70;
  sorted.forEach((pc,i)=>{
    const x=x0+i*dx;
    const y=66 - ((pc-0+12)%12)*2;
    s+=`<ellipse cx="${x}" cy="${y}" rx="12" ry="8" fill="rgba(15,23,42,.15)" stroke="rgba(107,114,128,.45)" stroke-width="2"/>`;
    const label=pcName(pc, preferFlats);
    s+=`<text x="${x}" y="${y+4}" text-anchor="middle" font-size="11" font-weight="900" fill="rgba(107,114,128,.95)">${label}</text>`;
  });
  svgEl.innerHTML=s;
}

/* ================= Audio (iOS unlock + reliable play) ================= */
let audioCtx=null, master=null;
function ensureAudio(){
  if(!audioCtx){
    audioCtx=new (window.AudioContext||window.webkitAudioContext)();
    master=audioCtx.createGain();
    master.gain.value=0.85;

    const comp=audioCtx.createDynamicsCompressor();
    comp.threshold.value=-20;
    comp.knee.value=18;
    comp.ratio.value=3.5;
    comp.attack.value=0.006;
    comp.release.value=0.12;

    master.connect(comp).connect(audioCtx.destination);
  }
  if(audioCtx.state==="suspended") audioCtx.resume();
}
function unlockAudioOnce(){
  ensureAudio();
  const now=audioCtx.currentTime;
  const o=audioCtx.createOscillator();
  const g=audioCtx.createGain();
  g.gain.setValueAtTime(0.0001, now);
  g.gain.exponentialRampToValueAtTime(0.0001, now+0.03);
  o.frequency.setValueAtTime(880, now);
  o.connect(g).connect(master);
  o.start(now); o.stop(now+0.03);
}
let audioUnlocked=false;
function ensureUnlockedByGesture(){
  if(audioUnlocked) return;
  try{ unlockAudioOnce(); audioUnlocked=true; }catch{}
}

function midiToHz(m){ return 440 * Math.pow(2, (m-69)/12); }
function pcToMidi(pc, baseMidi){
  const basePc = baseMidi % 12;
  let diff = (pc - basePc + 12) % 12;
  return baseMidi + diff;
}
function playOneNote(midi, t0){
  const f=midiToHz(midi);

  const filter=audioCtx.createBiquadFilter();
  filter.type="lowpass";
  filter.frequency.setValueAtTime(2200, t0);
  filter.Q.setValueAtTime(0.6, t0);

  const gain=audioCtx.createGain();
  gain.gain.setValueAtTime(0.0001, t0);
  gain.gain.exponentialRampToValueAtTime(0.32, t0+0.012);
  gain.gain.exponentialRampToValueAtTime(0.10, t0+0.18);
  gain.gain.exponentialRampToValueAtTime(0.0001, t0+1.2);

  const osc1=audioCtx.createOscillator(); osc1.type="triangle"; osc1.frequency.setValueAtTime(f, t0);
  const osc2=audioCtx.createOscillator(); osc2.type="sine"; osc2.frequency.setValueAtTime(f, t0); osc2.detune.setValueAtTime(6, t0);
  const osc3=audioCtx.createOscillator(); osc3.type="sine"; osc3.frequency.setValueAtTime(f, t0); osc3.detune.setValueAtTime(-6, t0);

  const mix=audioCtx.createGain(); mix.gain.setValueAtTime(0.95, t0);
  osc1.connect(mix); osc2.connect(mix); osc3.connect(mix);
  mix.connect(filter).connect(gain).connect(master);

  osc1.start(t0); osc2.start(t0); osc3.start(t0);
  osc1.stop(t0+1.25); osc2.stop(t0+1.25); osc3.stop(t0+1.25);
}
function playChord(pcs, mode, baseOct){
  ensureUnlockedByGesture();
  ensureAudio();
  const now=audioCtx.currentTime;
  const baseMidi = 12*(baseOct+1);
  const sorted=pcs.slice().sort((a,b)=>a-b);
  const order = mode==="desc" ? sorted.slice().reverse() : sorted.slice();
  order.forEach((pc,i)=>{
    const delay=(mode==="off")?0:i*0.085;
    const t0=now+delay;
    const midi=pcToMidi(pc, baseMidi) + 12;
    playOneNote(midi, t0);
  });
}
function playClickNote(pc, baseOct){
  ensureUnlockedByGesture();
  ensureAudio();
  const now=audioCtx.currentTime;
  const baseMidi=12*(baseOct+1);
  const midi=pcToMidi(pc, baseMidi)+12;
  playOneNote(midi, now);
}

/* ================= Keyboard SVG (Chord display + Interactive Piano) ================= */
function buildKeyboardSVG({highlightPcs, preferFlats, startOct, endOct, interactive, selectedSet, showBubbles=true}){
  const hi = new Set(highlightPcs||[]);
  const sel = selectedSet || new Set();

  const octaves = Math.max(1, (endOct - startOct));
  const addFinalC = true;

  const whiteW=58, whiteH=240, blackW=36, blackH=150;
  const whiteOrder=["C","D","E","F","G","A","B"];
  const whitePCs=[0,2,4,5,7,9,11];
  const blackAfter=[{after:"C",pc:1},{after:"D",pc:3},{after:"F",pc:6},{after:"G",pc:8},{after:"A",pc:10}];

  const totalWhite = octaves*7 + (addFinalC?1:0);
  const svgW = totalWhite*whiteW;

  let svg = `<svg viewBox="0 0 ${svgW} ${whiteH}" xmlns="http://www.w3.org/2000/svg">
    <defs>
      <linearGradient id="blkG" x1="0" y1="0" x2="0" y2="1">
        <stop offset="0" stop-color="#2a2f3a"/>
        <stop offset="0.45" stop-color="#141823"/>
        <stop offset="1" stop-color="#0b0f18"/>
      </linearGradient>
      <linearGradient id="blkShine" x1="0" y1="0" x2="1" y2="0">
        <stop offset="0" stop-color="rgba(255,255,255,0.12)"/>
        <stop offset="0.25" stop-color="rgba(255,255,255,0.04)"/>
        <stop offset="1" stop-color="rgba(0,0,0,0)"/>
      </linearGradient>
    </defs>
  `;

  const whiteX = idx => idx*whiteW;
  const whiteKeys=[];
  for(let o=0;o<octaves;o++){
    for(let i=0;i<7;i++) whiteKeys.push({pc:whitePCs[i], idx:o*7+i, octave:startOct+o});
  }
  if(addFinalC) whiteKeys.push({pc:0, idx:octaves*7, octave:startOct+octaves});

  // White keys
  for(const k of whiteKeys){
    const x=whiteX(k.idx);
    svg += `<rect x="${x}" y="0" width="${whiteW}" height="${whiteH}" rx="12"
      fill="var(--whiteKey)" stroke="var(--whiteKeyBorder)" stroke-width="2"/>`;

    if(k.pc===0){
      const lab=`C${k.octave}`;
      svg += `<text x="${x+10}" y="${whiteH-18}" font-size="20" font-weight="900" fill="rgba(107,114,128,.70)">${lab}</text>`;
    }

    if(interactive){
      svg += `<rect x="${x}" y="0" width="${whiteW}" height="${whiteH}" rx="12" fill="transparent" data-pc="${k.pc}" data-key="white" style="cursor:pointer"/>`;
    }
  }

  // Black keys
  for(let o=0;o<octaves;o++){
    for(const b of blackAfter){
      const i=whiteOrder.indexOf(b.after);
      const idx=o*7+i;
      const x=whiteX(idx)+(whiteW-blackW/2);
      svg += `<g>
        <rect x="${x}" y="0" width="${blackW}" height="${blackH}" rx="10" fill="url(#blkG)" stroke="#05070c" stroke-width="2"/>
        <rect x="${x+2}" y="2" width="${blackW-4}" height="${blackH-6}" rx="8" fill="url(#blkShine)" opacity="0.9"/>
        ${interactive ? `<rect x="${x}" y="0" width="${blackW}" height="${blackH}" rx="10" fill="transparent" data-pc="${b.pc}" data-key="black" style="cursor:pointer"/>` : ""}
      </g>`;
    }
  }

  // Bubbles
  if(showBubbles){
    const radius=26, pad=8;
    const focusOct = Math.min(1, Math.max(0, octaves-1));
    const baseIdx = focusOct*7;

    const centers=new Map();
    for(let i=0;i<7;i++){
      const pc=whitePCs[i];
      const idx=baseIdx+i;
      centers.set(pc,{x:whiteX(idx)+whiteW/2, y:whiteH-48, kind:"white"});
    }
    for(const b of blackAfter){
      const i=whiteOrder.indexOf(b.after);
      const idx=baseIdx+i;
      centers.set(b.pc,{x:whiteX(idx)+(whiteW-blackW/2)+blackW/2, y:62, kind:"black"});
    }

    const used = interactive ? uniq([...sel]) : uniq([...hi]);

    let bubbles=[];
    for(const pc of used){
      const c=centers.get(pc);
      if(!c) continue;
      bubbles.push({pc, x:c.x, y:c.y});
    }
    bubbles = resolveBubbleCollisions(bubbles, radius, pad);
    for(const b of bubbles){
      b.x = Math.max(radius+6, Math.min(svgW-radius-6, b.x));
      const label=pcName(b.pc, preferFlats);
      svg += `<circle cx="${b.x}" cy="${b.y}" r="${radius}" fill="var(--bubble)"/>`;
      svg += `<text x="${b.x}" y="${b.y+8}" text-anchor="middle" font-size="20" font-weight="900" fill="var(--bubbleText)">${label}</text>`;
    }
  }

  svg += `</svg>`;
  return svg;
}

/* ================= Chord candidates for Piano mode (fill LEFT list) ================= */
const QUALS = [
  {label:"Major", value:""},
  {label:"Minor", value:"m"},
  {label:"7", value:"7"},
  {label:"maj7", value:"maj7"},
  {label:"m7", value:"m7"},
  {label:"dim", value:"dim"},
  {label:"m7b5", value:"m7b5"},
  {label:"dim7", value:"dim7"},
  {label:"aug", value:"aug"},
  {label:"sus2", value:"sus2"},
  {label:"sus4", value:"sus4"},
  {label:"9", value:"9"},
  {label:"m9", value:"m9"},
  {label:"maj9", value:"maj9"},
  {label:"11", value:"11"},
  {label:"13", value:"13"},
  {label:"7b5", value:"7b5"},
  {label:"7#5", value:"7#5"},
  {label:"7b9", value:"7b9"},
  {label:"7#9", value:"7#9"},
  {label:"13#11", value:"13#11"},
];

function makeChordLookup(){
  const map=new Map(); // key pcs_sorted -> [{name, root, q, pcs}, ...]
  for(const r of NOTE_SHARP){
    for(const q of QUALS){
      const name=r+q.value;
      const p=parseChord(name);
      if(p.error) continue;
      const ch=buildChord(p);
      const key=ch.pcs.slice().sort((a,b)=>a-b).join(",");
      if(!map.has(key)) map.set(key,[]);
      map.get(key).push({name:ch.modernName, raw:name, pcs:ch.pcs, preferFlats:p.preferFlats});
    }
  }
  // Sort each entry: shorter names first, then alphabetical
  for(const [k, arr] of map.entries()){
    arr.sort((a,b)=>a.name.length-b.name.length || a.name.localeCompare(b.name));
  }
  return map;
}
const CHORD_LOOKUP = makeChordLookup();

/* ================= UI / State ================= */
const $ = (id)=>document.getElementById(id);
const KEY_FAV="piano_chords_fav_v5";

function loadArr(k){ try{return JSON.parse(localStorage.getItem(k)||"[]");}catch{return[];} }
function saveArr(k,a){ localStorage.setItem(k, JSON.stringify(a)); }

let state = {
  query:"Cm",
  arp:"off",
  invIndex:0,
  preferFlats:true,
  parsed:null,
  chord:null,
  inversions:[],
  modern:"",
  legacy:"",
  railRootIndex:0,
  railQualIndex:1,
  loop:false,
  leftInv:0,
  favFilter:false,
  viewTab:"root",
  rangeStart:3,
  rangeEnd:5,
  pianoSelected:new Set(),
};

function setErr(msg){
  const e=$("err");
  if(!msg){ e.style.display="none"; e.textContent=""; return; }
  e.style.display="block"; e.textContent=msg;
}

/* ================= Tabs & Views ================= */
function applyView(){
  const staffBox=$("staffBox");
  const infoTable=$("infoTable");

  if(state.viewTab==="piano"){
    staffBox.classList.add("viewHide");
    infoTable.classList.add("viewHide");
  }else{
    staffBox.classList.remove("viewHide");
    infoTable.classList.remove("viewHide");
  }
}

/* ================= Rails ================= */
function buildRootScroll(){
  const cont=$("rootScroll");
  cont.innerHTML="";
  ROOTS_RAIL.forEach((r,idx)=>{
    const b=document.createElement("button");
    b.textContent=r;
    if(idx===state.railRootIndex) b.classList.add("active");
    b.onclick=()=>{
      state.railRootIndex=idx;
      buildFromRails();
    };
    cont.appendChild(b);
  });
}
function renderRails(){
  const rail=$("noteRail");
  rail.innerHTML="";
  const show=["C","C#","Db","D","D#","Eb","E","F","F#","Gb"];
  const curRoot=ROOTS_RAIL[state.railRootIndex];
  show.forEach(n=>{
    const span=document.createElement("span");
    span.textContent=n;
    if(n===curRoot) span.className="active";
    rail.appendChild(span);
  });
  $("qualRail").innerHTML = `<span class="mut"> </span><span>${QUALS[state.railQualIndex].label}</span><span class="mut"> </span>`;

  [...$("rootScroll").querySelectorAll("button")].forEach((b,i)=>{
    b.classList.toggle("active", i===state.railRootIndex);
  });
}

function buildFromRails(){
  const root=ROOTS_RAIL[state.railRootIndex];
  const qual=QUALS[state.railQualIndex].value;
  const q=root+qual;
  $("searchInput").value=q;
  updateSearchClearUI();
  search(q);
}

/* ================= Search & Render (Chord mode) ================= */
function search(raw){
  setErr(null);

  const p=parseChord(raw);
  if(p.error){ setErr(p.error); return; }

  const ch=buildChord(p);
  state.parsed=p;
  state.chord=ch;
  state.inversions=inversionsFromPcs(ch.pcs);

  // Ensure invIndex always valid
  state.invIndex=Math.max(0, Math.min(state.invIndex, state.inversions.length-1));

  state.modern=ch.modernName;
  const looksLegacy = raw.includes("/") && /\/(7|6|9|11|13|5[+-]|9[+-]|11[+-]|13[+-])/.test(raw.replace(/\s+/g,""));
  state.legacy = looksLegacy ? raw : modernToLegacy(ch.modernName);
  state.preferFlats=p.preferFlats;

  $("rightTitle").textContent=state.modern;
  $("legacyLine").textContent=`Legacy: ${state.legacy}   |   Modern: ${state.modern}`;
  $("leftRootBig").textContent=p.root;

  syncRailsFromCurrent();
  renderRight();
  renderLeftList();
}

function syncRailsFromCurrent(){
  const p=state.parsed; if(!p) return;
  const legacy=state.legacy||"";
  const prefer = legacy.startsWith("Db")?"Db":
                 legacy.startsWith("Eb")?"Eb":
                 legacy.startsWith("Gb")?"Gb":
                 legacy.startsWith("Ab")?"Ab":
                 legacy.startsWith("Bb")?"Bb": p.root;

  const idx=ROOTS_RAIL.indexOf(prefer);
  if(idx>=0) state.railRootIndex=idx;

  const qualStr = state.modern.replace(p.root,"");
  const qidx = QUALS.findIndex(x=>x.value.toLowerCase()===qualStr.toLowerCase());
  if(qidx>=0) state.railQualIndex=qidx;

  renderRails();
}

function renderRight(){
  if(state.viewTab==="piano"){
    renderPianoMode();
    applyView();
    return;
  }

  const p=state.parsed, ch=state.chord;
  if(!p||!ch) return;

  const invPcs = state.inversions[state.invIndex] || ch.pcs;

  $("degText").textContent=degreesFromIntervals(ch.ints);
  $("noteText").textContent=invPcs.slice().sort((a,b)=>a-b).map(pc=>pcName(pc,state.preferFlats)).join(", ");

  // RIGHT inversions seg â€” always rebuild and always wire
  const invSeg=$("rightInvSeg");
  invSeg.innerHTML="";
  state.inversions.forEach((_,idx)=>{
    const b=document.createElement("button");
    b.textContent=invLabel(idx);
    b.classList.toggle("active", idx===state.invIndex);
    b.onclick=()=>{
      state.invIndex=idx;
      renderRight();
      renderLeftList();
    };
    invSeg.appendChild(b);
  });

  renderStaff($("staffSvg"), invPcs, state.preferFlats);

  $("kbdMain").innerHTML = buildKeyboardSVG({
    highlightPcs: invPcs,
    preferFlats: state.preferFlats,
    startOct: state.rangeStart,
    endOct: state.rangeEnd,
    interactive: false,
    showBubbles: true
  });

  // favorite star
  const fav=loadArr(KEY_FAV);
  $("favBtn").textContent = fav.includes(state.legacy) ? "â˜…" : "â˜†";

  applyView();
}

/* ================= LEFT list ================= */
function renderLeftList(){
  const list=$("chordList");
  const q=($("searchInput").value||"").trim().toLowerCase();
  const fav=loadArr(KEY_FAV);

  list.innerHTML="";

  // If Piano mode: show chord matches for selected notes
  if(state.viewTab==="piano"){
    const key = [...state.pianoSelected].sort((a,b)=>a-b).join(",");
    const matches = (CHORD_LOOKUP.get(key) || []).slice(0, 80);

    // If user typed something in search while in piano mode, filter matches by text
    const filtered = matches.filter(x => !q || x.name.toLowerCase().includes(q) || modernToLegacy(x.name).toLowerCase().includes(q));

    if(!state.pianoSelected.size){
      const empty=document.createElement("div");
      empty.style.padding="12px";
      empty.style.color="var(--mut)";
      empty.style.fontWeight="900";
      empty.textContent="Tap keys to select notes â€” matches will appear here.";
      list.appendChild(empty);
      return;
    }

    if(!filtered.length){
      const empty=document.createElement("div");
      empty.style.padding="12px";
      empty.style.color="var(--mut)";
      empty.style.fontWeight="900";
      empty.textContent="No exact chord match for the selected notes (try adding/removing a note).";
      list.appendChild(empty);
      return;
    }

    filtered.forEach(x=>{
      const div=document.createElement("div");
      div.className="item";
      div.onclick=()=>{
        // Choose this chord => switch to Root tab, reset inversion to Root
        state.viewTab="root";
        setTabUI("root");
        state.invIndex=0;

        $("searchInput").value = x.name;
        updateSearchClearUI();
        search(x.name);
        $("searchInput").blur();
      };

      const nameBox=document.createElement("div");
      const legacy=modernToLegacy(x.name);
      const star = fav.includes(legacy) ? "â˜…" : "â˜†";
      nameBox.innerHTML=`<div class="name">${x.name}</div><div class="sub">Legacy: ${legacy} &nbsp; ${star}</div>`;

      const mini=document.createElement("div");
      mini.className="miniKbd";
      // show the chord on mini keyboard
      const p=parseChord(x.name); if(!p.error){
        const ch=buildChord(p);
        const invPcs=inversionsFromPcs(ch.pcs)[0];
        mini.innerHTML = buildKeyboardSVG({
          highlightPcs: invPcs,
          preferFlats: p.preferFlats,
          startOct: 3,
          endOct: 4,
          interactive:false,
          showBubbles:false
        });
      }

      div.appendChild(nameBox);
      div.appendChild(mini);
      list.appendChild(div);
    });

    $("favFilterBtn").textContent = state.favFilter ? "All" : "Show â˜…";
    return;
  }

  // Root mode list (by root + quality)
  const root = state.parsed?.root || ROOTS_RAIL[state.railRootIndex] || "C";
  const items = QUALS.map(x => (root + x.value));

  items
    .filter(name => !q || name.toLowerCase().includes(q) || modernToLegacy(name).toLowerCase().includes(q) || normalizeWordSearch(name).toLowerCase().includes(q))
    .filter(name => {
      if(!state.favFilter) return true;
      const p=parseChord(name); if(p.error) return false;
      const ch=buildChord(p);
      const legacy=modernToLegacy(ch.modernName);
      return fav.includes(legacy);
    })
    .forEach(name=>{
      const p=parseChord(name); if(p.error) return;
      const ch=buildChord(p);

      const invs=inversionsFromPcs(ch.pcs);
      const invPcs=invs[state.leftInv] || invs[0];

      const div=document.createElement("div");
      div.className="item"+((state.modern===ch.modernName && state.viewTab!=="piano")?" active":"");
      div.onclick=()=>{
        state.viewTab="root";
        setTabUI("root");
        state.invIndex=0; // selecting from list resets to root inversion

        $("searchInput").value=name;
        updateSearchClearUI();
        search(name);
        $("searchInput").blur();
      };

      const nameBox=document.createElement("div");
      const legacy=modernToLegacy(ch.modernName);
      const star = fav.includes(legacy) ? "â˜…" : "â˜†";
      nameBox.innerHTML=`<div class="name">${ch.modernName}</div><div class="sub">Legacy: ${legacy} &nbsp; ${star}</div>`;

      const mini=document.createElement("div");
      mini.className="miniKbd";
      mini.innerHTML = buildKeyboardSVG({
        highlightPcs: invPcs,
        preferFlats: p.preferFlats,
        startOct: 3,
        endOct: 4,
        interactive:false,
        showBubbles:false
      });

      div.appendChild(nameBox);
      div.appendChild(mini);
      list.appendChild(div);
    });

  $("favFilterBtn").textContent = state.favFilter ? "All" : "Show â˜…";
}

/* ================= Piano mode (interactive keys + clear + play) ================= */
function renderPianoMode(){
  const key = [...state.pianoSelected].sort((a,b)=>a-b).join(",");
  const matches = (CHORD_LOOKUP.get(key) || []).map(x=>x.name);

  if(matches.length){
    $("rightTitle").textContent = matches[0];
    $("legacyLine").textContent = `Detected: ${matches.slice(0,4).join("  â€¢  ")}`;
  }else{
    const notes = [...state.pianoSelected].sort((a,b)=>a-b).map(pc=>pcName(pc,true)).join(", ");
    $("rightTitle").textContent = "Piano";
    $("legacyLine").textContent = notes ? `Selected: ${notes}` : "Tap keys to select notes";
  }

  $("rightInvSeg").innerHTML = "";
  $("degText").textContent = "â€”";
  $("noteText").textContent = "â€”";

  $("kbdMain").innerHTML = buildKeyboardSVG({
    highlightPcs: [],
    preferFlats: true,
    startOct: state.rangeStart,
    endOct: state.rangeEnd,
    interactive: true,
    selectedSet: state.pianoSelected,
    showBubbles: true
  });

  wireKeyboardInteractions();
  renderLeftList(); // IMPORTANT: fill left list with matches
}

function wireKeyboardInteractions(){
  const svg = $("kbdMain").querySelector("svg");
  if(!svg) return;

  const hit = svg.querySelectorAll("[data-pc]");
  hit.forEach(el=>{
    el.addEventListener("pointerdown",(e)=>{
      e.preventDefault();
      ensureUnlockedByGesture();

      const pc = parseInt(el.getAttribute("data-pc"),10);
      if(state.pianoSelected.has(pc)) state.pianoSelected.delete(pc);
      else state.pianoSelected.add(pc);

      playClickNote(pc, state.rangeStart);
      renderPianoMode();
    }, {passive:false});
  });
}

/* ================= Favorites ================= */
function toggleFav(){
  const fav=loadArr(KEY_FAV);
  const key=state.legacy;
  if(!key) return;
  const next = fav.includes(key) ? fav.filter(x=>x!==key) : [key].concat(fav).slice(0,400);
  saveArr(KEY_FAV,next);
  $("favBtn").textContent = next.includes(key) ? "â˜…":"â˜†";
  renderLeftList();
}

/* ================= Search clear UI ================= */
function updateSearchClearUI(){
  const v = ($("searchInput").value||"").trim();
  $("clearSearchBtn").classList.toggle("show", v.length>0);
}

/* ================= Misc UI ================= */
function toggleTheme(){
  const body=document.body;
  const dark = body.getAttribute("data-theme")==="dark";
  body.setAttribute("data-theme", dark ? "light" : "dark");
  $("themeBtn").textContent = dark ? "â˜€ï¸Ž" : "â˜¾";
}

function setTabUI(tab){
  $("topTabs").querySelectorAll("button").forEach(x=>x.classList.remove("active"));
  const btn=[...$("topTabs").querySelectorAll("button")].find(b=>b.dataset.tab===tab);
  if(btn) btn.classList.add("active");
  state.viewTab=tab;
}

/* ================= Init / Events ================= */
function init(){
  // iOS audio unlock: any first user gesture
  const unlockHandler = ()=>{
    ensureUnlockedByGesture();
    window.removeEventListener("pointerdown", unlockHandler, true);
    window.removeEventListener("touchstart", unlockHandler, true);
    window.removeEventListener("click", unlockHandler, true);
  };
  window.addEventListener("pointerdown", unlockHandler, true);
  window.addEventListener("touchstart", unlockHandler, true);
  window.addEventListener("click", unlockHandler, true);

  $("themeBtn").onclick=toggleTheme;
  $("favBtn").onclick=toggleFav;

  $("favFilterBtn").onclick=()=>{
    state.favFilter=!state.favFilter;
    renderLeftList();
  };

  // Tabs
  $("topTabs").querySelectorAll("button").forEach(b=>{
    b.onclick=()=>{
      setTabUI(b.dataset.tab);
      renderRight();
      applyView();
    };
  });

  // Search: Enter => search + blur (close iPad keyboard)
  $("searchInput").addEventListener("keydown",(e)=>{
    if(e.key==="Enter"){
      const v=$("searchInput").value.trim();
      if(v){
        // Keep current tab as-is; search affects chord mode primarily.
        // If user is in piano mode and types a chord: switch to root
        if(state.viewTab==="piano"){
          state.viewTab="root";
          setTabUI("root");
          state.invIndex=0;
        }
        search(v);
      }
      $("searchInput").blur();
    }
  });

  $("searchInput").addEventListener("input", ()=>{
    updateSearchClearUI();
    renderLeftList();
  });

  // Search clear X
  $("clearSearchBtn").onclick=()=>{
    $("searchInput").value="";
    updateSearchClearUI();
    // If in piano mode, keep matches list (based on selected keys)
    renderLeftList();
    $("searchInput").focus();
  };

  // Left inversion segment affects mini list only
  $("leftInvSeg").querySelectorAll("button").forEach(btn=>{
    btn.onclick=()=>{
      $("leftInvSeg").querySelectorAll("button").forEach(x=>x.classList.remove("active"));
      btn.classList.add("active");
      state.leftInv=parseInt(btn.dataset.inv,10);
      renderLeftList();
    };
  });

  // Root rail arrows
  $("rootPrev").onclick=()=>{ state.railRootIndex=(state.railRootIndex-1+ROOTS_RAIL.length)%ROOTS_RAIL.length; buildFromRails(); };
  $("rootNext").onclick=()=>{ state.railRootIndex=(state.railRootIndex+1)%ROOTS_RAIL.length; buildFromRails(); };

  // Quality arrows
  $("qualPrev").onclick=()=>{ state.railQualIndex=(state.railQualIndex-1+QUALS.length)%QUALS.length; buildFromRails(); };
  $("qualNext").onclick=()=>{ state.railQualIndex=(state.railQualIndex+1)%QUALS.length; buildFromRails(); };

  // Loop toggle visual
  $("loopToggle").onclick=()=>{ state.loop=!state.loop; $("loopToggle").classList.toggle("on", state.loop); };

  // Arp mode
  $("arpSeg").querySelectorAll("button").forEach(b=>{
    b.onclick=()=>{
      $("arpSeg").querySelectorAll("button").forEach(x=>x.classList.remove("active"));
      b.classList.add("active");
      state.arp=b.dataset.arp;
    };
  });

  // Clear button (Piano mode)
  $("clearBtn").onclick=()=>{
    ensureUnlockedByGesture();
    state.pianoSelected.clear();
    if(state.viewTab==="piano") renderPianoMode();
    else renderLeftList();
  };

  // Play button
  $("playBtn").onclick=()=>{
    ensureUnlockedByGesture();
    if(state.viewTab==="piano"){
      const pcs=[...state.pianoSelected];
      if(!pcs.length) return;
      playChord(pcs, state.arp, state.rangeStart);
      return;
    }
    if(!state.chord) return;
    const pcs = state.inversions[state.invIndex] || state.chord.pcs;
    playChord(pcs, state.arp, state.rangeStart);
  };

  // Range selects
  $("rangeStart").onchange=()=>{
    state.rangeStart=parseInt($("rangeStart").value,10);
    if(state.rangeEnd <= state.rangeStart) state.rangeEnd = state.rangeStart+1;
    $("rangeEnd").value=String(state.rangeEnd);
    renderRight();
  };
  $("rangeEnd").onchange=()=>{
    state.rangeEnd=parseInt($("rangeEnd").value,10);
    if(state.rangeEnd <= state.rangeStart) state.rangeEnd = state.rangeStart+1;
    $("rangeEnd").value=String(state.rangeEnd);
    renderRight();
  };

  // Root scroll
  buildRootScroll();

  // Default range
  state.rangeStart=parseInt($("rangeStart").value,10);
  state.rangeEnd=parseInt($("rangeEnd").value,10);

  // Start chord
  $("searchInput").value="Cm";
  updateSearchClearUI();
  state.viewTab="root";
  renderRails();
  search("Cm");
  applyView();
}

init();
</script>
</body>
</html>
